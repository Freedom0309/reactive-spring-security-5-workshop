= Spring Security 5 Hands-On Workshop
Andreas Falk <andreas.falk@novatec-gmbh.de>
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectlinks:
:numbered: ''
:docinfo:

image::images/spring_io_workshop.jpg[scaledwidth="50%", scaledheight="50%",alt="springio_workshop"]

== Introduction

Target of this workshop is to learn how to make an initially unsecured web application
more and more secure step-by-step.

This will be done in following steps:

1. Add spring boot security starter dependency for simple auto configuration of security
2. Customize authentication configuration (provide our own user store and adapted authentication rules)
3. Add authorization (access controls) to web and method layers
4. Implement security integration tests
5. Experiment with new reactive OAuth2 Login Client

== Common Web Security Risks

In this workshop you will strive various parts of securing a web application that
fit into the https://www.owasp.org/index.php/Top_10-2017_Top_10[OWASP Top 10 2017 list].

We will look at:

- A2: Broken Authentication
- A3: Sensitive Data Exposure
- A5: Broken Access Control
- A6: Security Misconfiguration
- A10: Insufficient Logging & Monitoring

image::images/owasp_top_10_2017.png[scaledwidth="50%", scaledheight="50%",alt="owasp_top_10"]

You may also have a look into the https://www.owasp.org/index.php/OWASP_Proactive_Controls[OWASP ProActive Controls] document which describes how to develop
your applications using good security patterns.

== The workshop application

In this workshop you will be provided a finished but completely unsecured reactive
web application. This library server application provides a RESTful service for administering books and users.

The RESTful service for books is build using the Spring WebFlux annotation model and the RESTful service for
users is build using the Spring WebFlux router model.

The application contains a complete documentation for the RESTful API build with spring rest docs
which you can find in the directory _build/asciidoc/html5_
after performing a full gradle build.

The domain model of this application is quite simple and just consists of _Book_ and _User_.
The packages of the application are organized as follows:

- *api*: Contains the complete RESTful service
- *business*: All the service classes (quite simple for workshop, usually containing business logic)
- *dataaccess*: All domain models and repositories
- *config*: All spring configuration classes

[NOTE]
====
For users of IntelliJ you find http scripts to test all the RESTful services in sub directory _http_
of all projects.
====

There are three target user roles for this application:

- *Standard users*: A standard user can borrow and return his currently borrowed books
- *Curators*: A curator user can add or delete books
- *Administrators*: An administrator user can add or remove users

The application is build using

- Spring 5 WebFlux on Netty
- Spring Data MongoDB with reactive driver
- In-memory Mongodb to have an easier setup for the workshop

== Workshop Organization

This interactive hands-on workshop is organized into several step with one step building upon each other.
There is a separate project for each step:

- 00-library-server: This contains the initial unsecured application
- 01-library-server: This has just added the spring boot starter dependencies for spring security
- 02-library-server: This adds a persistent user store for authentication
- 03-library-server: This adds custom authentication and authorization rules
- 04-library-server: This adds automatic integration tests for authorization

=== Requirements for this workshop

- Some free disk space
- Git
- A Java 8 or 9 JDK
- Any IDE capable of building with Gradle (IntelliJ, Eclipse, VS Code, ...)

== Workshop Steps

To start the workshop please begin by adapting the _00-library-server_ application.

[NOTE]
====
If you are not able to keep up with completing a particular step you
always can just start over with the existing application of next step.

For example if you could not manage to complete the tutorial based on _01-library-server_
just continue using _02-library-server_.
====

=== Step 1: Auto Configuration

In the first step we start quite easy by just adding the spring boot starter dependency for spring security
to the _build.gradle_ file of the initial application (_00-library-server_).

.build.gradle

include::{snippets}/step-1-gradle-build.adoc[]

Please start the application by running the class _LibraryServerApplication_.

image::images/loginform.png[scaledwidth="40%", scaledheight="40%",alt="owasp_top_10"]

If you browse to http://localhost:8080/books[localhost:8080/books] then you will notice
that a login form appears in the browser window.

[TIP]
====
But wait - what are the credentials for a user to log in?

With spring security autoconfigured by spring boot the credentials are as follows:

* Username=user
* Password=<Look into the console log!>
====

.console log

include::{snippets}/step-1-default-password-console.adoc[]

As you can see, if Spring Security is on the classpath,
then the web application is secured by default.
https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-security[Spring boot] auto-configured
basic authentication and form based authentication for all web endpoints.

This also applies to all actuator endpoints like http://localhost:8080/actuator/health[/actuator/health].
All monitoring web endpoints can now only be accessed with an authenticated user.
See https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-security-actuator[Actuator Security]
for details.

Additionally spring security improved the security of the web application automatically for:

* https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#ns-session-fixation[Session Fixation]
* https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf[Cross Site Request Forgery (CSRF)]
* https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#default-security-headers[Default Security Headers]
** This automatically adds all recommended security response headers to all http responses. You can find more information about this topic
   in the https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Main[OWASP Secure Headers Project]

.default security response headers

include::{snippets}/step-1-security-response-header.adoc[]

Spring security 5 also added a bit more user friendly logout functionality out of the box.
If you direct your browser to http://localhost:8080/logout[localhost:8080/logout] you will see the following
dialog on the screen.

image::images/logoutform.png[scaledwidth="40%", scaledheight="40%",alt="owasp_top_10"]

This concludes the first step. Now let's proceed to next step and start with customizing
the authentication part.

=== Step 2: Customize Authentication

Now it is time to start customizing the auto-configuration. The spring boot auto-configuration will back-off a bit in
this step and will back-off completely in next step.

We start by replacing the default user/password with our own persistent user storage (already present in MongoDB).
To do this we add a new class _WebSecurityConfiguration_ to package _com.example.library.server.config_ having the following
contents.

.WebSecurityConfiguration class

include::{snippets}/step-2-password-encoder-config.adoc[]

This does two things:

. This adds the _SecurityWebFilterChain_. If you already have secured servlet based spring mvc web applications
  then you might know what's called the _spring security filter chain_. In spring webflux the _SecurityWebFilterChain_ is the similar approach
  based on WebFilter.
. Configures a _PasswordEncoder_. A password encoder is used by spring security to encrypt passwords and to check
  if a given password matches the encrypted one.

.PasswordEncoder interface

include::{snippets}/step-2-password-encoder.adoc[]

Now that we already have configured the encrypting part for passwords of our user storage
we need to connect our own user store (the users already stored in the MongoDB) with spring security's
authentication manager.


.LibraryUser class

include::{snippets}/step-2-library-user.adoc[]


.LibraryReactiveUserDetailsService class

include::{snippets}/step-2-library-user-details-service.adoc[]


.DataInitializer class

include::{snippets}/step-2-data-initializer.adoc[]



=== Step 3: Add Authorization


.WebSecurityConfiguration class

include::{snippets}/step-3-spring-security-filter-chain.adoc[]


.BookService class

include::{snippets}/step-3-book-authorization.adoc[]


.UserService class

include::{snippets}/step-3-user-authorization.adoc[]


.BookRestController class

include::{snippets}/step-3-authentication-principal.adoc[]


=== Step 4: Security Testing


.BookServiceTest class

include::{snippets}/step-4-book-authorization-test.adoc[]


.UserServiceTest class

include::{snippets}/step-4-user-authorization-test.adoc[]

=== Step 5: Add OAuth2 Client

==== What we will build

.We will extend the existing two microservices to use single sign authentication based on OAuth2.

* OAuth2 Authorization Server: This is the new microservice for single sign on which holds all users with their credentials
* OAuth2 Resource Server (Product Backend): The microservice providing product data maps to a resource server
* OAuth2 Client (UI Microservice): The thymeleaf UI microservice consuming the products maps to an OAuth2 client

image::images/oauth2services.png[scaledwidth="75%",alt="OAuth2 roles"]

These microservices have to be configured to be reachable via the following URL addresses (Port 8080 is the default port in spring boot).

.Microservice URL Adresses
|===
|Microservice |URL
|Authorization Server
|http://localhost:9999/auth
|Client (Library-UI)
|http://localhost:8081
|Resource Server (Library-Server)
|http://localhost:8080
|===

TIP: You can find more information on building OAuth2 secured microservices with spring in
http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-security-oauth2[Spring Boot Reference Documentation]
and in https://projects.spring.io/spring-security-oauth/docs/oauth2.html[Spring Security OAuth2 Developers Guide]

In step 1 we will build a basic OAuth2 secured microservices infrastructure using simple user credentials provided
via properties in _application.properties_.

[[authorization-server]]
==== Authorization Server

TIP: You may look into the spring boot reference documentation http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-security-oauth2-authorization-server[Spring Boot Reference Documentation]
on how to implement an authorization server.

IMPORTANT: To prevent conflicts with different JSESSION cookies the authorization server must run
on a separate context path (not '/'). In our example please use '/auth' as context path. In spring boot
this can be achieved by the _server.context_ property

To ensure OAuth2 authorization code grant works correctly with the other components the end points
of the authorization server must be as follows:

.Authorization Server Endpoints
|===
|Endpoint |Description |Caller
|/oauth/authorize
|Authorization endpoint (for login and client authorization)
|Client
|/oauth/token
|Token endpoint (exchanges given authorization code for access token)
|Client
|/oauth/check_token
|Check token endpoint (returns internal contents for access token)
|Resource Server
|===

[[authorization-server-maven-dependencies]]
===== Gradle dependencies

include::{snippets}/authserver-mavenpom.adoc[]

<1> Dependency for OAuth2 security support

===== Java Implementation

include::{snippets}/authserver-java.adoc[]

<1> Annotation to enable auto configuration of an Authorization Server

[[authorization-server-configuration]]
===== Configuration

include::{snippets}/authserver-props.adoc[]

<1> Definition of username for authentication
<2> Definition of user password for authentication
<3> Client id for OAuth2 authorization code grant
<4> Client secret for OAuth2 authorization code grant
<5> Scopes to authorize for OAuth2
<6> Open endpoint for getting token details for authenticated users

[[resource-server]]
==== Resource Server (Library-Server)

[[resource-server-maven-dependencies]]
===== Maven dependencies

Add the following required dependencies to the existing maven pom file.

include::{snippets}/resourceserver-mavenpom.adoc[]

===== Java Implementation

The existing products service now should act as an OAuth2 resource server.
Therefore it has to be marked as such.

include::{snippets}/resourceserver-java.adoc[]

<1> Annotation to enable this as a OAuth2 resource server.

[[resource-server-configuration]]
===== Configuration

The following additional properties are required to make the resource server work with our new
authorization server.

include::{snippets}/resourceserver-props.adoc[]

<1> This password won't be used as this microservice is protected by OAuth2 now
<2> Endpoint for getting token details required for products resource server
<3> Client id for OAuth2 authorization code grant
<4> Client secret for OAuth2 authorization code grant

[[client]]
==== OAuth2 Client (UI)

[[client-maven-dependencies]]
===== Maven dependencies

Add the following required dependencies to the existing maven pom file.

include::{snippets}/client-mavenpom.adoc[]

[[client-java-implementation]]
===== Java Implementation

The UI client now acts as OAuth2 client and must be marked as such.
Additionally to automatically use the OAuth2 tokens with all calls to REST services
the currently used _RestTemplate_ has to be replaced with new _OAuth2RestTemplate_

NOTE: In more advanced cloud scenarios you may also
use http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#spring-cloud-feign[Feign Client]
instead of _OAuth2RestTemplate_ to call the REST Api. In that case you have to add an interceptor
for OAuth2.

include::{snippets}/client-java.adoc[]

<1> Add _@EnableOAuth2Sso_ annotation to secure complete UI using OAuth2
<2> Add new _@Bean_ configuration for OAuth2RestTemplate (will replace the standard _RestTemplate_)

include::{snippets}/client-service-java.adoc[]

<1> Replace standard _RestTemplate_ with _OAuth2RestTemplate_
<2> Reconfigure HystrixCommand to use Semaphore to propagate the security context

[[client-configuration]]
===== Configuration

The following additional properties are required to make the UI client work with our new
authorization server.

include::{snippets}/client-props.adoc[]

<1> This password won't be used as this microservice is protected by OAuth2 now
<2> Client id for OAuth2 authorization code grant
<3> Client secret for OAuth2 authorization code grant
<4> Endpoint for exchanging authorization code for access token
<5> Endpoint for redirecting to authorization server for authentication
<6> Scope for the request
<7> Endpoint for validating token details

.To make the sample application even more secure we will enhance the authorization server to...
- ...enable login using a form login page
- ...use a persistent store for users
- ...encrypt the passwords

==== Provide form based login

A form based login is more user friendly authentication and should always be preferred over
basic authentication popups.
To provide an automatically generated form based login just extend the predefined class _WebSecurityConfigurerAdapter_.

include::{snippets}/authserver-formlogin-java.adoc[]

==== Use persistent store

Until now we have authenticated ourselves using credentials that are defined via application properties
which is ok for demo purposes but definitely not for production use.

.Therefore we introduce a new persistent _User_ entity which has the following attributes:
- firstname
- lastname
- email
- password

NOTE: To actually use the new _User_ entity with spring security this entity class has to implement the predefined
interface _UserDetails_ as well. Please use the attribute _email_ as _username_.

A corresponding repository interface and a data initializer component (just like the one for products)
have to be implemented as well.

Finally spring security must be aware to use the persistent users now instead of the one
defined in the properties. To achieve this you have to implement the interface
_UserDetailsService_ as well to provide an operation loading a user for authentication.

include::{snippets}/authserver-userdetailsservice-java.adoc[]

include::{snippets}/authserver-userdetailsservice-cfg-java.adoc[]

==== Encrypt the passwords

In the last step we want to change the storage of cleartext passwords for the users in the database.
If any attacker gets hold of our database then all passwords are leaked.
Therefore a production system must *ALWAYS* store any sensible data like passwords, credit card numbers etc.
encrypted using a proven cryptographic algorithm.

include::{snippets}/password-encoder-java.adoc[]

.Lucklily spring security already provides safe implementations of a _PasswordEncoder_:
- Pbkdf2PasswordEncoder
- BCryptPasswordEncoder
- SCryptPasswordEncoder

To support authentication using encrypted passwords the current web security configuration has to be extended
by the _PasswordEncoder_ to be used.

include::{snippets}/authserver-passwordencoder-cfg-java.adoc[]

NOTE: The passwords have to be stored in encrypted form as well,
so don't forget to inject and use a _PasswordEncoder_ instance in
your user data initializer.

TIP: You may use the h2 console to have a look into the in-memory database to see that the user passwords
are really stored as encrypted values now.
See http://docs.spring.io/spring-boot/docs/1.5.3.RELEASE/reference/htmlsingle/#boot-features-sql-h2-console[Spring Boot Reference Docs] on
how to use and configure this.

